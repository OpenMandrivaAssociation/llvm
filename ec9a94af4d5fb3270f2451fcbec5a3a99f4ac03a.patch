From ec9a94af4d5fb3270f2451fcbec5a3a99f4ac03a Mon Sep 17 00:00:00 2001
From: Craig Topper <craig.topper@intel.com>
Date: Thu, 6 Feb 2020 13:10:32 -0800
Subject: [PATCH] [X86] Use MVT::i8 instead of MVT::i64 for shift amount in
 BuildSDIVPow2

X86 uses i8 for shift amounts. This code can fail on a 32-bit target
if it runs after type legalization.

This code was copied from AArch64 and modified for X86, but the
shift amount wasn't changed to the correct type for X86.

Fixes PR44812
---
 llvm/lib/Target/X86/X86ISelLowering.cpp |  2 +-
 llvm/test/CodeGen/X86/pr44812.ll        | 24 ++++++++++++++++++++++++
 2 files changed, 25 insertions(+), 1 deletion(-)
 create mode 100644 llvm/test/CodeGen/X86/pr44812.ll

diff --git a/llvm/lib/Target/X86/X86ISelLowering.cpp b/llvm/lib/Target/X86/X86ISelLowering.cpp
index af86e20b3955..280f6822997e 100644
--- a/llvm/lib/Target/X86/X86ISelLowering.cpp
+++ b/llvm/lib/Target/X86/X86ISelLowering.cpp
@@ -21134,7 +21134,7 @@ X86TargetLowering::BuildSDIVPow2(SDNode *N, const APInt &Divisor,
 
   // Divide by pow2.
   SDValue SRA =
-      DAG.getNode(ISD::SRA, DL, VT, CMov, DAG.getConstant(Lg2, DL, MVT::i64));
+      DAG.getNode(ISD::SRA, DL, VT, CMov, DAG.getConstant(Lg2, DL, MVT::i8));
 
   // If we're dividing by a positive value, we're done.  Otherwise, we must
   // negate the result.
diff --git a/llvm/test/CodeGen/X86/pr44812.ll b/llvm/test/CodeGen/X86/pr44812.ll
new file mode 100644
index 000000000000..7c4dc67dc9c0
--- /dev/null
+++ b/llvm/test/CodeGen/X86/pr44812.ll
@@ -0,0 +1,24 @@
+; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
+; RUN: llc < %s -mtriple=i386-unknown-linux-gnu -mattr=cmov | FileCheck %s
+
+define <2 x i32> @foo(<2 x i32> %tmp)  {
+; CHECK-LABEL: foo:
+; CHECK:       # %bb.0: # %entry
+; CHECK-NEXT:    movl {{[0-9]+}}(%esp), %eax
+; CHECK-NEXT:    leal 7(%eax), %ecx
+; CHECK-NEXT:    testl %eax, %eax
+; CHECK-NEXT:    cmovnsl %eax, %ecx
+; CHECK-NEXT:    sarl $3, %ecx
+; CHECK-NEXT:    movl $1717986919, %eax # imm = 0x66666667
+; CHECK-NEXT:    imull {{[0-9]+}}(%esp)
+; CHECK-NEXT:    movl %edx, %eax
+; CHECK-NEXT:    shrl $31, %eax
+; CHECK-NEXT:    sarl $2, %edx
+; CHECK-NEXT:    addl %edx, %eax
+; CHECK-NEXT:    movl %ecx, %edx
+; CHECK-NEXT:    retl
+entry:
+  %tmp1 = sdiv <2 x i32> %tmp, <i32 10, i32 8>
+  ret <2 x i32> %tmp1
+}
+
