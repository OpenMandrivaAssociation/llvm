From c37b1a5f764380f83ba08ae0cebca2b162123eb6 Mon Sep 17 00:00:00 2001
From: Philip Reames <preames@rivosinc.com>
Date: Mon, 29 Aug 2022 11:37:42 -0700
Subject: [PATCH] [RLEV] Pick a correct insert point when incoming instruction
 is itself a phi node

This fixes https://github.com/llvm/llvm-project/issues/57336. It was exposed by a recent SCEV change, but appears to have been a long standing issue.

Note that the whole insert into the loop instead of a split exit edge is slightly contrived to begin with; it's there solely because IndVarSimplify preserves the CFG.

Differential Revision: https://reviews.llvm.org/D132571
---
 llvm/lib/Transforms/Utils/LoopUtils.cpp       |  5 ++-
 .../IndVarSimplify/rewrite-loop-exit-value.ll | 38 +++++++++++++++++++
 2 files changed, 42 insertions(+), 1 deletion(-)

diff --git a/llvm/lib/Transforms/Utils/LoopUtils.cpp b/llvm/lib/Transforms/Utils/LoopUtils.cpp
index 92f47a117faa..1287c3aa0a9e 100644
--- a/llvm/lib/Transforms/Utils/LoopUtils.cpp
+++ b/llvm/lib/Transforms/Utils/LoopUtils.cpp
@@ -1395,7 +1395,10 @@ int llvm::rewriteLoopExitValues(Loop *L, LoopInfo *LI, TargetLibraryInfo *TLI,
         // and next SCEV may errneously get smaller cost.
 
         // Collect all the candidate PHINodes to be rewritten.
-        RewritePhiSet.emplace_back(PN, i, ExitValue, Inst, HighCost);
+        Instruction *InsertPt =
+          (isa<PHINode>(Inst) || isa<LandingPadInst>(Inst)) ?
+          &*Inst->getParent()->getFirstInsertionPt() : Inst;
+        RewritePhiSet.emplace_back(PN, i, ExitValue, InsertPt, HighCost);
       }
     }
   }
diff --git a/llvm/test/Transforms/IndVarSimplify/rewrite-loop-exit-value.ll b/llvm/test/Transforms/IndVarSimplify/rewrite-loop-exit-value.ll
index a8f713bbf127..aac87039d9bc 100644
--- a/llvm/test/Transforms/IndVarSimplify/rewrite-loop-exit-value.ll
+++ b/llvm/test/Transforms/IndVarSimplify/rewrite-loop-exit-value.ll
@@ -158,4 +158,42 @@ exit:
   ret i32 %phi_indvar
 }
 
+define i16 @pr57336(i16 %end, i16 %m) mustprogress {
+; CHECK-LABEL: @pr57336(
+; CHECK-NEXT:  entry:
+; CHECK-NEXT:    br label [[FOR_BODY:%.*]]
+; CHECK:       for.body:
+; CHECK-NEXT:    [[INC8:%.*]] = phi i16 [ [[INC:%.*]], [[FOR_BODY]] ], [ 0, [[ENTRY:%.*]] ]
+; CHECK-NEXT:    [[INC]] = add nuw nsw i16 [[INC8]], 1
+; CHECK-NEXT:    [[MUL:%.*]] = mul nsw i16 [[INC8]], [[M:%.*]]
+; CHECK-NEXT:    [[CMP_NOT:%.*]] = icmp sgt i16 [[MUL]], [[END:%.*]]
+; CHECK-NEXT:    br i1 [[CMP_NOT]], label [[CRIT_EDGE:%.*]], label [[FOR_BODY]]
+; CHECK:       crit_edge:
+; CHECK-NEXT:    [[TMP0:%.*]] = call i16 @llvm.smax.i16(i16 [[END]], i16 -1)
+; CHECK-NEXT:    [[SMAX:%.*]] = add nsw i16 [[TMP0]], 1
+; CHECK-NEXT:    [[TMP1:%.*]] = icmp ne i16 [[SMAX]], 0
+; CHECK-NEXT:    [[UMIN:%.*]] = zext i1 [[TMP1]] to i16
+; CHECK-NEXT:    [[TMP2:%.*]] = sub nsw i16 [[SMAX]], [[UMIN]]
+; CHECK-NEXT:    [[UMAX:%.*]] = call i16 @llvm.umax.i16(i16 [[M]], i16 1)
+; CHECK-NEXT:    [[TMP3:%.*]] = udiv i16 [[TMP2]], [[UMAX]]
+; CHECK-NEXT:    [[TMP4:%.*]] = add i16 [[TMP3]], [[UMIN]]
+; CHECK-NEXT:    ret i16 [[TMP4]]
+;
+entry:
+  br label %for.body
+
+for.body:
+  %inc8 = phi i16 [ %inc, %for.body ], [ 0, %entry ]
+  %inc137 = phi i32 [ %inc1, %for.body ], [ 0, %entry ]
+  %inc1 = add nsw i32 %inc137, 1
+  %inc = add nsw i16 %inc8, 1
+  %mul = mul nsw i16 %m, %inc8
+  %cmp.not = icmp slt i16 %end, %mul
+  br i1 %cmp.not, label %crit_edge, label %for.body
+
+crit_edge:
+  %inc137.lcssa = phi i32 [ %inc137, %for.body ]
+  %conv = trunc i32 %inc137.lcssa to i16
+  ret i16 %conv
+}
 
