From 912870573c5f55b3f6dc4494a608e3ee9c2f730d Mon Sep 17 00:00:00 2001
From: Craig Topper <craig.topper@intel.com>
Date: Tue, 1 Oct 2019 21:55:55 +0000
Subject: [PATCH] [X86] convertToThreeAddress, make sure second operand of
 SUB32ri is really an immediate before calling getImm().

It might be a symbol instead. We can't fold those since we can't
negate them.

Similar for other SUB with immediates.

Fixes PR43529.

llvm-svn: 373397
---
 llvm/lib/Target/X86/X86InstrInfo.cpp |  4 +++
 llvm/test/CodeGen/X86/pr43529.ll     | 39 ++++++++++++++++++++++++++++
 2 files changed, 43 insertions(+)
 create mode 100644 llvm/test/CodeGen/X86/pr43529.ll

diff --git a/llvm/lib/Target/X86/X86InstrInfo.cpp b/llvm/lib/Target/X86/X86InstrInfo.cpp
index 7fba03c6425..3c68ac2291f 100644
--- a/llvm/lib/Target/X86/X86InstrInfo.cpp
+++ b/llvm/lib/Target/X86/X86InstrInfo.cpp
@@ -1122,6 +1122,8 @@ X86InstrInfo::convertToThreeAddress(MachineFunction::iterator &MFI,
     return nullptr;
   case X86::SUB32ri8:
   case X86::SUB32ri: {
+    if (!MI.getOperand(2).isImm())
+      return nullptr;
     int64_t Imm = MI.getOperand(2).getImm();
     if (!isInt<32>(-Imm))
       return nullptr;
@@ -1148,6 +1150,8 @@ X86InstrInfo::convertToThreeAddress(MachineFunction::iterator &MFI,
 
   case X86::SUB64ri8:
   case X86::SUB64ri32: {
+    if (!MI.getOperand(2).isImm())
+      return nullptr;
     int64_t Imm = MI.getOperand(2).getImm();
     if (!isInt<32>(-Imm))
       return nullptr;
diff --git a/llvm/test/CodeGen/X86/pr43529.ll b/llvm/test/CodeGen/X86/pr43529.ll
new file mode 100644
index 00000000000..afccf5e46d7
--- /dev/null
+++ b/llvm/test/CodeGen/X86/pr43529.ll
@@ -0,0 +1,39 @@
+; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
+; RUN: llc < %s -mtriple=i386-unknown-linux-gnu | FileCheck %s
+
+define i32 @a() nounwind {
+; CHECK-LABEL: a:
+; CHECK:       # %bb.0: # %entry
+; CHECK-NEXT:    pushl %esi
+; CHECK-NEXT:    subl $8, %esp
+; CHECK-NEXT:    leal {{[0-9]+}}(%esp), %esi
+; CHECK-NEXT:    movl %esi, %eax
+; CHECK-NEXT:    subl $a, %eax
+; CHECK-NEXT:    calll d
+; CHECK-NEXT:    cmpl $a, %esi
+; CHECK-NEXT:    jbe .LBB0_2
+; CHECK-NEXT:    .p2align 4, 0x90
+; CHECK-NEXT:  .LBB0_1: # %for.cond
+; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
+; CHECK-NEXT:    jmp .LBB0_1
+; CHECK-NEXT:  .LBB0_2: # %for.end.split
+; CHECK-NEXT:    addl $8, %esp
+; CHECK-NEXT:    popl %esi
+; CHECK-NEXT:    retl
+entry:
+  %b = alloca i32, align 4
+  %0 = bitcast i32* %b to i8*
+  %1 = ptrtoint i32* %b to i32
+  %sub = sub nsw i32 %1, ptrtoint (i32 ()* @a to i32)
+  %call = call i32 bitcast (i32 (...)* @d to i32 (i32)*)(i32 inreg %sub)
+  %cmp = icmp ugt i32* %b, bitcast (i32 ()* @a to i32*)
+  br i1 %cmp, label %for.cond, label %for.end.split
+
+for.cond:                                         ; preds = %entry, %for.cond
+  br label %for.cond
+
+for.end.split:                                    ; preds = %entry
+  ret i32 undef
+}
+
+declare i32 @d(...)
-- 
2.21.0

