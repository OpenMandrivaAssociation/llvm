diff -up llvm-project-main/clang/lib/Driver/ToolChains/Linux.cpp.11~ llvm-project-main/clang/lib/Driver/ToolChains/Linux.cpp
--- llvm-project-main/clang/lib/Driver/ToolChains/Linux.cpp.11~	2022-01-18 18:35:58.520171110 +0100
+++ llvm-project-main/clang/lib/Driver/ToolChains/Linux.cpp	2022-01-18 18:36:57.473519242 +0100
@@ -286,6 +286,7 @@ Linux::Linux(const Driver &D, const llvm
         Paths);
   }
 
+  addPathIfExists(D, SysRoot + "/usr/" + MultiarchTriple + "/lib", Paths); // OMV 5.x+
   addPathIfExists(D, SysRoot + "/usr/lib/" + MultiarchTriple, Paths);
   // 64-bit OpenEmbedded sysroots may not have a /usr/lib dir. So they cannot
   // find /usr/lib64 as it is referenced as /usr/lib/../lib64. So we handle
@@ -301,7 +302,12 @@ Linux::Linux(const Driver &D, const llvm
     addPathIfExists(D, SysRoot + "/usr/" + OSLibDir + "/" + ABIName, Paths);
   }
 
+#if 0
+  // This is actually harmful unconditionally because it adds
+  //         /usr/bin/../lib64/gcc/x86_64-openmandriva-linux-gnu/10.0.0/../../..
+  // ( == /usr/lib64 ) even in -m32 mode. Let's NOT do it.
   Generic_GCC::AddMultiarchPaths(D, SysRoot, OSLibDir, Paths);
+#endif
 
   // Similar to the logic for GCC above, if we are currently running Clang
   // inside of the requested system root, add its parent library path to those
